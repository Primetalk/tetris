# Tetris

A tutorial tetris implementation in Scala.js.
The goal of this tutorial is to demonstrate a good way 
of using Scala.

Key principles:
1. Appropriate abstractions.
2. Immutability.
3. Single responsibility principle.
4. Readability

## Step 1. Bootstrap Scala.js project

See http://www.scala-js.org/doc/tutorial/basic/ 
for the introduction of Scala.js.

## Step 2. Direct rules modelling

We take rules of the game and translate them literally 
to Scala version.

Notes and nuances:
 - we have two representations of Tetriminos - the list of relative points
   and the list of rows.
 - rotation can also represent an angle. We have 4 rotations and 4 angles. 
   we may consider an angle to be a rotation from the original position.
 - velocity/speed is represented by time that it takes to pass a single row.

## Step 3. Side story about vectors and rotations

Introduce `Rotations` trait. Sometimes we need small DSLs for the sake of
readability.
In games we often use some math...
In `Rotations` trait one may find an example of an Abelian group :). 

## Step 4. Algorithms

Data structures help or not help writing algorithms.

 - conversion of points to rows. One data structure that is convenient to rotations
   to another data structure that is convenient to moves and the rest of game logic
 - collision detection
 - merge of board and shape, "bake" the board
  
Notes: tailrec

Also No mutability!

## Step 5. GameMechanics

Game can be in one of the following states: running, completed, or paused.

Transition between these states happen via either user interaction or timer. Hence, we have events.

Most of events influence the falling tetrimino. So we have a separate method that calculates the result of interaction.
Some of the interactions might not be possible and we return `None`.

In paused state we ignore all events.

We also provide the initial state to the game in `startGame`.

We do not pass random number generator. Just use pregenerated `Int`. This makes it
deterministic and makes testing easier.

Still no mutability. We produce new version of state after event handling.

One consequence of having no mutable state is that we can create an object.

## Step 6. Rendering

Mutable external context. Moving parts are redrawn using background color.

## Step 7. Controller

The first `var`s - game state and .

## Step 8. HTML integration

In `.html` file:
1. Include `tetris-fastopt.js` script. The script is generated by `sbt fastOptJS`.
2. Call exported `startGame`, where we start the controller.

## Step 9. Running

1. `sbt fastOptJS` - generate .js script.
2. Open `index-dev.html` in browser.
3. Enjoy